#!/usr/bin/env python3
"""
Frontend Streamlit para o Chatbot Epson com ChromaDB
Interface web moderna para o sistema de busca sem√¢ntica
"""

import streamlit as st
import google.generativeai as genai
import json
import time
import re
import os
import sys
from datetime import datetime

# Adiciona path para importar m√≥dulos
sys.path.append(os.path.join(os.path.dirname(__file__), 'scripts'))

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Chatbot Epson - Suporte T√©cnico",
    page_icon="üñ®Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Importa√ß√µes do sistema principal
from core.chatbot_chromadb import (
    init_chromadb,
    sync_printer_metadata_from_chromadb,
    enhanced_search_chromadb,
    get_printer_metadata_dynamic,
    call_api_detailed,
    format_response,
    can_make_request,
    check_and_reload_manual,
    PRINTER_METADATA,
    normalize_text,
    find_similar_printers
)

# Configura√ß√£o da API Gemini
# Tenta pegar do secrets, se n√£o existir usa a key padr√£o
try:
    GEMINI_API_KEY = st.secrets["GEMINI_API_KEY"]
except:
    GEMINI_API_KEY = "AIzaSyDjejxDFqTSg_i-KDnS2QqsXdiWLydIrSk"

genai.configure(api_key=GEMINI_API_KEY)

# Inicializa√ß√£o do estado da sess√£o
if 'messages' not in st.session_state:
    st.session_state.messages = []
if 'chromadb_initialized' not in st.session_state:
    st.session_state.chromadb_initialized = False
if 'chromadb_search' not in st.session_state:
    st.session_state.chromadb_search = None
if 'available_models' not in st.session_state:
    st.session_state.available_models = []
if 'selected_printer' not in st.session_state:
    st.session_state.selected_printer = None
if 'response_mode' not in st.session_state:
    st.session_state.response_mode = 'detalhado'
if 'last_update_check' not in st.session_state:
    st.session_state.last_update_check = datetime.now()
if 'question_count' not in st.session_state:
    st.session_state.question_count = 0
if 'funnel_active' not in st.session_state:
    st.session_state.funnel_active = False
if 'funnel_stage' not in st.session_state:
    st.session_state.funnel_stage = None
if 'funnel_answers' not in st.session_state:
    st.session_state.funnel_answers = {}
if 'pending_question' not in st.session_state:
    st.session_state.pending_question = None

def init_system():
    """Inicializa o sistema ChromaDB"""
    if not st.session_state.chromadb_initialized:
        with st.spinner('üöÄ Inicializando sistema ChromaDB...'):
            try:
                # Inicializa ChromaDB
                from core.chatbot_chromadb import chromadb_search, using_chromadb
                init_chromadb()
                st.session_state.chromadb_search = chromadb_search
                
                # Sincroniza metadados
                sync_printer_metadata_from_chromadb()
                
                # Obt√©m modelos dispon√≠veis
                if chromadb_search:
                    st.session_state.available_models = chromadb_search.get_available_printer_models()
                else:
                    st.session_state.available_models = list(PRINTER_METADATA.keys())
                
                st.session_state.chromadb_initialized = True
                return True
                
            except Exception as e:
                st.error(f"‚ùå Erro ao inicializar ChromaDB: {e}")
                st.info("üí° Execute: `python scripts/sync_drive_chromadb.py` para configurar o ChromaDB")
                return False
    return True

def check_for_updates():
    """Verifica atualiza√ß√µes na base de conhecimento"""
    try:
        is_updated, status = check_and_reload_manual()
        if is_updated:
            st.info(f"üîÑ {status}")
            # Re-sincroniza se houver atualiza√ß√µes
            sync_printer_metadata_from_chromadb()
            if st.session_state.chromadb_search:
                st.session_state.available_models = st.session_state.chromadb_search.get_available_printer_models()
        return is_updated, status
    except Exception as e:
        return False, f"Erro ao verificar atualiza√ß√µes: {e}"

def detect_printer_from_query(query):
    """Detecta modelo de impressora na query"""
    # Primeiro tenta detec√ß√£o simples
    query_lower = normalize_text(query)
    
    for model_id, metadata in PRINTER_METADATA.items():
        # Verifica aliases
        for alias in metadata.get('aliases', []):
            if normalize_text(alias) in query_lower:
                return model_id
        
        # Verifica nome completo
        if normalize_text(metadata['full_name']) in query_lower:
            return model_id
    
    # Tenta detec√ß√£o por similaridade
    similar = find_similar_printers(query, 0.7)
    if similar:
        return similar[0][0]  # Retorna o primeiro match
    
    return None

def process_user_query(query, printer_model, mode='detalhado'):
    """Processa a pergunta do usu√°rio"""
    try:
        # Busca sem√¢ntica no ChromaDB
        with st.spinner('üîç Buscando informa√ß√µes relevantes...'):
            manual_sections = enhanced_search_chromadb(query, printer_model)
        
        if not manual_sections:
            return None, "Nenhuma informa√ß√£o relevante encontrada no manual."
        
        # Gera resposta com Gemini
        with st.spinner('ü§ñ Gerando resposta...'):
            success, response = call_api_detailed(query, manual_sections, mode, printer_model)
        
        if success:
            formatted = format_response(response)
            sources_count = len(manual_sections)
            return formatted, f"üìö Baseado em {sources_count} se√ß√£o(√µes) do manual"
        else:
            return None, response
            
    except Exception as e:
        return None, f"Erro ao processar pergunta: {e}"

def filter_printers_by_features(answers):
    """Filtra impressoras baseado nas respostas do usu√°rio"""
    available = []
    
    # Mapeia caracter√≠sticas para modelos baseado nos metadados dispon√≠veis
    printer_features = {}
    
    print(f"DEBUG: Modelos dispon√≠veis no sistema: {st.session_state.available_models}")
    
    # Usa os modelos dispon√≠veis do sistema e suas caracter√≠sticas conhecidas
    for model_id in st.session_state.available_models:
        # Caracter√≠sticas conhecidas dos modelos
        if 'L805' in model_id or 'l805' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': False, 'fax': False, 'adf': False, 'duplex': False}
        elif 'L1300' in model_id or 'l1300' in model_id:
            printer_features[model_id] = {'a3': True, 'multifuncional': False, 'fax': False, 'adf': False, 'duplex': False}
        elif 'L375' in model_id or 'l375' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': False, 'adf': False, 'duplex': False}
        elif 'L396' in model_id or 'l396' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': False, 'adf': False, 'duplex': False}
        elif 'L3110' in model_id or 'l3110' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': False, 'adf': False, 'duplex': False}
        elif 'L3150' in model_id or 'l3150' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': False, 'adf': False, 'duplex': False}
        elif ('L3250' in model_id or 'l3250' in model_id) or ('L3251' in model_id or 'l3251' in model_id):
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': False, 'adf': False, 'duplex': True}
        elif 'L4150' in model_id or 'l4150' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': False, 'adf': True, 'duplex': True}
        elif 'L4260' in model_id or 'l4260' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': False, 'adf': True, 'duplex': True}
        elif 'L5190' in model_id or 'l5190' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': True, 'adf': True, 'duplex': True}
        elif 'L5290' in model_id or 'l5290' in model_id:
            printer_features[model_id] = {'a3': False, 'multifuncional': True, 'fax': True, 'adf': True, 'duplex': True}
        elif 'L6490' in model_id or 'l6490' in model_id:
            printer_features[model_id] = {'a3': True, 'multifuncional': True, 'fax': False, 'adf': True, 'duplex': True}
    
    print(f"DEBUG: Features mapeadas: {printer_features}")
    print(f"DEBUG: Respostas do usu√°rio para filtrar: {answers}")
    
    # Filtra baseado nas respostas
    for model_id, features in printer_features.items():
        match = True
        
        # Verifica cada resposta
        if 'multifuncional' in answers:
            if answers['multifuncional'] != features['multifuncional']:
                match = False
        
        if 'a3' in answers:
            if answers['a3'] != features['a3']:
                match = False
        
        if 'duplex' in answers:
            if answers['duplex'] != features['duplex']:
                match = False
        
        if 'adf' in answers:
            if answers['adf'] != features['adf']:
                match = False
        
        if 'fax' in answers:
            if answers['fax'] != features['fax']:
                match = False
        
        if match:
            available.append(model_id)
    
    return available

def get_funnel_question(stage, answers):
    """Retorna a pr√≥xima pergunta do afunilamento baseado no est√°gio"""
    
    if stage == 1:
        return {
            'question': "üñ®Ô∏è **Sua impressora √© multifuncional?**\n\n(Multifuncional = imprime, copia e digitaliza)",
            'options': ['Sim, √© multifuncional', 'N√£o, s√≥ imprime', 'N√£o sei'],
            'key': 'multifuncional'
        }
    
    # Se n√£o √© multifuncional, pula direto para A3
    if stage == 2 and answers.get('multifuncional') == False:
        return {
            'question': "üìÑ **Sua impressora suporta papel A3?**\n\n(A3 = folha grande, 420mm √ó 297mm)",
            'options': ['Sim, imprime A3', 'N√£o, apenas A4', 'N√£o sei'],
            'key': 'a3'
        }
    
    # Se √© multifuncional, pergunta sobre duplex
    if stage == 2 and answers.get('multifuncional') == True:
        return {
            'question': "üìë **Sua impressora imprime frente e verso automaticamente (duplex)?**",
            'options': ['Sim, tem duplex', 'N√£o, apenas um lado', 'N√£o sei'],
            'key': 'duplex'
        }
    
    # Pergunta sobre ADF (para multifuncionais)
    if stage == 3 and answers.get('multifuncional') == True:
        return {
            'question': "üìã **Sua impressora tem alimentador autom√°tico de documentos (ADF)?**\n\n(ADF = bandeja na parte superior para digitalizar v√°rias folhas)",
            'options': ['Sim, tem ADF', 'N√£o, s√≥ vidro do scanner', 'N√£o sei'],
            'key': 'adf'
        }
    
    # Pergunta sobre FAX (para multifuncionais com ADF)
    if stage == 4 and answers.get('multifuncional') == True and answers.get('adf') == True:
        return {
            'question': "üì† **Sua impressora tem fun√ß√£o de FAX?**",
            'options': ['Sim, tem FAX', 'N√£o tem FAX', 'N√£o sei'],
            'key': 'fax'
        }
    
    # Pergunta sobre A3 (para multifuncionais)
    if (stage == 5 or (stage == 4 and answers.get('adf') != True)) and answers.get('multifuncional') == True:
        return {
            'question': "üìÑ **Sua impressora suporta papel A3?**\n\n(A3 = folha grande, 420mm √ó 297mm)",
            'options': ['Sim, imprime A3', 'N√£o, apenas A4', 'N√£o sei'],
            'key': 'a3'
        }
    
    return None

def start_funnel():
    """Inicia o processo de afunilamento"""
    st.session_state.funnel_active = True
    st.session_state.funnel_stage = 1
    st.session_state.funnel_answers = {}

def process_funnel_answer(answer, key):
    """Processa a resposta do afunilamento"""
    # Mapeia resposta para booleano
    if "Sim" in answer:
        st.session_state.funnel_answers[key] = True
    elif "N√£o" in answer and "N√£o sei" not in answer:
        st.session_state.funnel_answers[key] = False
    # Se "N√£o sei", n√£o adiciona ao filtro
    
    # Debug: mostra respostas coletadas
    print(f"DEBUG: Resposta processada - {key}: {st.session_state.funnel_answers.get(key, 'N√£o sei')}")
    print(f"DEBUG: Todas respostas at√© agora: {st.session_state.funnel_answers}")
    
    # Avan√ßa para pr√≥ximo est√°gio
    st.session_state.funnel_stage += 1
    print(f"DEBUG: Avan√ßando para est√°gio {st.session_state.funnel_stage}")
    
    # Verifica se j√° pode identificar a impressora
    filtered = filter_printers_by_features(st.session_state.funnel_answers)
    print(f"DEBUG: Modelos filtrados: {filtered} (Total: {len(filtered)})")
    
    if len(filtered) == 1:
        # Encontrou √∫nica impressora
        st.session_state.selected_printer = filtered[0]
        st.session_state.funnel_active = False
        st.session_state.funnel_stage = None
        return True, filtered[0]
    elif len(filtered) == 0:
        # Nenhuma impressora corresponde
        st.session_state.funnel_active = False
        st.session_state.funnel_stage = None
        return False, None
    elif st.session_state.funnel_stage > 5 or get_funnel_question(st.session_state.funnel_stage, st.session_state.funnel_answers) is None:
        # M√°ximo de perguntas atingido ou n√£o h√° mais perguntas
        if len(filtered) <= 3 and len(filtered) > 0:
            # Mostra op√ß√µes restantes
            if len(filtered) == 2:
                # Se s√£o exatamente 2 modelos, mostra ambos para escolha
                return None, filtered
            else:
                # Se s√£o 3 modelos, tamb√©m mostra para escolha
                return None, filtered
        elif len(filtered) == 1:
            # Encontrou √∫nica impressora ap√≥s todas perguntas
            st.session_state.selected_printer = filtered[0]
            st.session_state.funnel_active = False
            st.session_state.funnel_stage = None
            return True, filtered[0]
        else:
            # Nenhuma impressora ou muitas op√ß√µes
            st.session_state.funnel_active = False
            st.session_state.funnel_stage = None
            return False, None
    
    return None, None

# Interface principal
def main():
    # Inicializa o sistema
    if not init_system():
        st.stop()
    
    # Header principal
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        st.title("üñ®Ô∏è Chatbot Epson")
        st.markdown("**Sistema Inteligente de Suporte T√©cnico**")
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Configura√ß√µes")
        
        # Status do sistema
        if st.session_state.chromadb_initialized:
            st.success("‚úÖ ChromaDB Ativo")
            st.info(f"üìö {len(st.session_state.available_models)} modelos dispon√≠veis")
        else:
            st.error("‚ùå ChromaDB n√£o inicializado")
        
        st.markdown("---")
        
        # Sele√ß√£o de impressora
        st.subheader("üñ®Ô∏è Impressora")
        
        # Se h√° impressora identificada pelo afunilamento
        if st.session_state.selected_printer and not st.session_state.funnel_active:
            current_printer_name = PRINTER_METADATA.get(
                st.session_state.selected_printer, {}
            ).get('full_name', st.session_state.selected_printer)
            st.success(f"üìå Identificada: **{current_printer_name}**")
        
        # Lista de modelos para sele√ß√£o
        model_options = ["Detectar automaticamente"] + [
            PRINTER_METADATA.get(m, {}).get('full_name', m) 
            for m in st.session_state.available_models 
            if m in PRINTER_METADATA
        ]
        
        # Define o √≠ndice padr√£o baseado na impressora selecionada
        default_index = 0
        if st.session_state.selected_printer:
            printer_name = PRINTER_METADATA.get(st.session_state.selected_printer, {}).get('full_name')
            if printer_name in model_options:
                default_index = model_options.index(printer_name)
        
        selected = st.selectbox(
            "Selecione o modelo:",
            options=model_options,
            index=default_index,
            help="Escolha sua impressora ou deixe o sistema detectar"
        )
        
        if selected != "Detectar automaticamente":
            # Encontra o ID do modelo baseado no nome completo
            for model_id, metadata in PRINTER_METADATA.items():
                if metadata.get('full_name') == selected:
                    # Se mudou de modelo, limpa afunilamento
                    if st.session_state.selected_printer != model_id:
                        st.session_state.funnel_active = False
                        st.session_state.funnel_stage = None
                        st.session_state.funnel_answers = {}
                        
                        # Se tinha uma pergunta pendente e selecionou modelo, processa
                        if st.session_state.pending_question and st.session_state.selected_printer is None:
                            st.session_state.messages.append({
                                "role": "assistant",
                                "content": f"‚úÖ **Modelo selecionado: {selected}**\n\nVou responder sua pergunta agora!"
                            })
                    
                    st.session_state.selected_printer = model_id
                    break
        else:
            st.session_state.selected_printer = None
        
        st.markdown("---")
        
        # Modo de resposta
        st.subheader("üí¨ Modo de Resposta")
        
        mode = st.radio(
            "Escolha o tipo de resposta:",
            options=['detalhado', 'rapido'],
            format_func=lambda x: 'üìñ Detalhado' if x == 'detalhado' else '‚ö° R√°pido',
            help="Detalhado: explica√ß√µes completas | R√°pido: respostas diretas"
        )
        st.session_state.response_mode = mode
        
        st.markdown("---")
        
        # Bot√µes de a√ß√£o
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üîÑ Atualizar", use_container_width=True):
                with st.spinner("Verificando..."):
                    updated, msg = check_for_updates()
                    if updated:
                        st.success("Base atualizada!")
                    else:
                        st.info(msg)
        
        with col2:
            if st.button("üóëÔ∏è Limpar Chat", use_container_width=True):
                st.session_state.messages = []
                st.session_state.question_count = 0
                st.session_state.funnel_active = False
                st.session_state.funnel_stage = None
                st.session_state.funnel_answers = {}
                st.session_state.pending_question = None
                st.rerun()
        
        # Bot√£o para cancelar afunilamento
        if st.session_state.funnel_active:
            st.markdown("---")
            if st.button("‚ùå Cancelar Identifica√ß√£o", use_container_width=True, type="secondary"):
                st.session_state.funnel_active = False
                st.session_state.funnel_stage = None
                st.session_state.funnel_answers = {}
                st.session_state.pending_question = None
                st.rerun()
        
        st.markdown("---")
        
        # Informa√ß√µes
        st.caption("**Vers√£o:** 2.0 ChromaDB")
        st.caption(f"**Perguntas:** {st.session_state.question_count}")
        
        # Dicas
        with st.expander("üí° Dicas de Uso"):
            st.markdown("""
            **Como usar:**
            1. Digite sua pergunta sobre impressoras Epson
            2. O sistema detectar√° o modelo automaticamente
            3. Ou selecione manualmente na barra lateral
            
            **Exemplos de perguntas:**
            - Como trocar a tinta?
            - Impressora n√£o liga
            - Configurar Wi-Fi
            - Papel emperrado
            
            **Modos:**
            - **Detalhado**: Passo a passo completo
            - **R√°pido**: Resposta direta em 3-4 passos
            """)
    
    # √Årea principal do chat
    
    # Verifica atualiza√ß√µes a cada 10 perguntas
    if st.session_state.question_count > 0 and st.session_state.question_count % 10 == 0:
        check_for_updates()
    
    # Mensagem de boas-vindas
    if len(st.session_state.messages) == 0:
        with st.chat_message("assistant"):
            st.markdown("""üëã **Ol√°! Sou o assistente t√©cnico Epson!**
            
Posso ajudar com:
- üîß Problemas t√©cnicos e solu√ß√µes
- üñ®Ô∏è Configura√ß√£o de impressoras
- üé® Qualidade de impress√£o
- üì° Conex√£o Wi-Fi e rede
- üõ†Ô∏è Manuten√ß√£o e limpeza

**Digite sua pergunta abaixo!**""")
    
    # Exibe hist√≥rico de mensagens
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
            if message.get("source"):
                st.caption(message["source"])
    
    # Sistema de afunilamento ativo
    if st.session_state.funnel_active:
        question_data = get_funnel_question(st.session_state.funnel_stage, st.session_state.funnel_answers)
        
        if question_data:
            # Mostra pergunta do afunilamento
            with st.chat_message("assistant"):
                # Mostra progresso
                if st.session_state.funnel_stage > 1:
                    progress = f"üìä Pergunta {st.session_state.funnel_stage} de no m√°ximo 5\n\n"
                    st.markdown(progress)
                
                st.markdown(question_data['question'])
                
                # Bot√µes de resposta
                cols = st.columns(len(question_data['options']))
                for i, option in enumerate(question_data['options']):
                    with cols[i]:
                        if st.button(option, key=f"funnel_btn_{st.session_state.funnel_stage}_{i}", use_container_width=True):
                            # Processa resposta
                            result, data = process_funnel_answer(option, question_data['key'])
                            
                            # Adiciona ao hist√≥rico
                            st.session_state.messages.append({
                                "role": "user", 
                                "content": option
                            })
                            st.session_state.messages.append({
                                "role": "assistant",
                                "content": question_data['question']
                            })
                            
                            if result is True:
                                # Impressora identificada
                                printer_name = PRINTER_METADATA.get(data, {}).get('full_name', data)
                                
                                # Adiciona mensagem de identifica√ß√£o ao hist√≥rico
                                success_msg = f"‚úÖ **Impressora identificada: {printer_name}**\n\nAgora posso responder sua pergunta!"
                                st.session_state.messages.append({
                                    "role": "assistant",
                                    "content": success_msg
                                })
                                
                                # Marca impressora como selecionada
                                st.session_state.selected_printer = data
                                
                                # Se h√° pergunta pendente, adiciona ao hist√≥rico para processar
                                if st.session_state.pending_question:
                                    # Adiciona a pergunta pendente como se fosse nova
                                    st.session_state.messages.append({
                                        "role": "user",
                                        "content": f"[Pergunta original] {st.session_state.pending_question}"
                                    })
                                    
                                    # Processa a pergunta
                                    with st.spinner('ü§ñ Processando sua pergunta...'):
                                        response, source = process_user_query(
                                            st.session_state.pending_question,
                                            data,
                                            st.session_state.response_mode
                                        )
                                        
                                        if response:
                                            mode_emoji = "‚ö°" if st.session_state.response_mode == 'rapido' else "üìñ"
                                            header = f"{mode_emoji} **[{printer_name}]**\n\n"
                                            st.session_state.messages.append({
                                                "role": "assistant",
                                                "content": header + response,
                                                "source": source
                                            })
                                            st.session_state.question_count += 1
                                
                                # Limpa estado do afunilamento
                                st.session_state.funnel_active = False
                                st.session_state.funnel_stage = None
                                st.session_state.funnel_answers = {}
                                st.session_state.pending_question = None
                                
                                st.rerun()
                            elif result is False:
                                st.error("‚ùå N√£o foi poss√≠vel identificar uma impressora com essas caracter√≠sticas.")
                                st.session_state.pending_question = None
                                st.rerun()
                            elif result is None and data:
                                # M√∫ltiplas op√ß√µes - permite escolha
                                st.session_state.messages.append({
                                    "role": "assistant",
                                    "content": f"üîç **Encontrei {len(data)} modelos poss√≠veis com essas caracter√≠sticas:**"
                                })
                                
                                # Limpa afunilamento e mostra op√ß√µes para escolha manual
                                st.session_state.funnel_active = False
                                st.session_state.funnel_stage = None
                                
                                # Adiciona mensagem com modelos poss√≠veis
                                models_list = "\n".join([f"‚Ä¢ {PRINTER_METADATA.get(m, {}).get('full_name', m)}" for m in data])
                                st.session_state.messages.append({
                                    "role": "assistant",
                                    "content": f"{models_list}\n\n**Por favor, selecione o modelo na barra lateral ou digite o modelo espec√≠fico.**"
                                })
                                
                                st.rerun()
                            else:
                                st.rerun()
        else:
            # Fim do afunilamento sem resultado
            st.session_state.funnel_active = False
            st.session_state.funnel_stage = None
    
    # Input do usu√°rio
    if prompt := st.chat_input("Digite sua pergunta sobre impressoras Epson..."):
        # Adiciona mensagem do usu√°rio
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)
        
        # Verifica rate limiting
        can_proceed, rate_msg = can_make_request()
        if not can_proceed:
            with st.chat_message("assistant"):
                st.warning(rate_msg)
            st.stop()
        
        # Detecta ou usa impressora selecionada
        printer_model = st.session_state.selected_printer
        
        if not printer_model:
            # Tenta detectar da query
            detected = detect_printer_from_query(prompt)
            if detected:
                printer_model = detected
                printer_name = PRINTER_METADATA.get(detected, {}).get('full_name', detected)
                with st.chat_message("assistant"):
                    st.info(f"üîç Impressora detectada: **{printer_name}**")
            else:
                # Inicia processo de afunilamento
                st.session_state.pending_question = prompt
                start_funnel()
                st.rerun()
        
        # Se chegou aqui, tem modelo de impressora
        if printer_model:
            # Nome da impressora para exibi√ß√£o
            printer_name = PRINTER_METADATA.get(printer_model, {}).get('full_name', printer_model)
            
            # Processa a pergunta
            response, source = process_user_query(
                prompt, 
                printer_model,
                st.session_state.response_mode
            )
            
            # Exibe resposta
            with st.chat_message("assistant"):
                if response:
                    # Adiciona indicador do modelo e modo
                    mode_emoji = "‚ö°" if st.session_state.response_mode == 'rapido' else "üìñ"
                    header = f"{mode_emoji} **[{printer_name}]**\n\n"
                    st.markdown(header + response)
                    
                    # Exibe fonte
                    if source:
                        st.caption(source)
                    
                    # Salva no hist√≥rico
                    st.session_state.messages.append({
                        "role": "assistant",
                        "content": header + response,
                        "source": source
                    })
                    
                    # Incrementa contador
                    st.session_state.question_count += 1
                    
                else:
                    # Erro ou sem resultados
                    st.error(source or "N√£o foi poss√≠vel gerar uma resposta.")
                    
                    # Dicas
                    st.info("""üí° **Dicas:**
‚Ä¢ Tente reformular sua pergunta
‚Ä¢ Use termos mais espec√≠ficos
‚Ä¢ Verifique se o modelo da impressora est√° correto""")
    
    # Footer com m√©tricas
    if st.session_state.question_count > 0:
        st.markdown("---")
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üìä Perguntas", st.session_state.question_count)
        with col2:
            st.metric("üñ®Ô∏è Modelos", len(st.session_state.available_models))
        with col3:
            mode_text = "R√°pido" if st.session_state.response_mode == 'rapido' else "Detalhado"
            st.metric("‚öôÔ∏è Modo", mode_text)

if __name__ == "__main__":
    main()
